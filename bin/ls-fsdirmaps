#!/usr/bin/env bash
# Using my configured file system aliases, echo all directory aliases
# alongside the absolute directory they point to in PATH like form.

print_usage() {
  echo "Usage: $(basename "$0") [-h] [-r] [-e]"
}

print_help() {
  print_usage
  echo ""
  echo "Using my configured aliases, filter out all filesystem"
  echo "aliases and present them to the user with file paths"
  echo "properly expanded."
  echo ""
  echo "Options:"
  echo "  -h    show this help message and exit"
  echo "  -r    replace '$HOME' with ~/ before outputting"
  echo "  -e    only show dirmaps that currently exist."
}

while getopts 'hre' option; do
  case "$option" in
    h) print_help
       exit 0 ;;
    \?) print_help >&2
        exit 1 ;;
    r) home_relative=1 ;;
    e) exists_only=1 ;;
  esac
done

has_stdbuf=0
envsubst_cmd='envsubst'
if command -v stdbuf >/dev/null 2>&1; then
  envsubst_cmd="stdbuf -oL $envsubst_cmd"
  has_stdbuf=1
fi

. build-aliases
read_script $(ls-aliases) |
  awk -v check_exists="${exists_only}" \
      -v home_relative="${home_relative}" \
      -v home="$HOME" \
      -v sep=":" \
      -v envsubst="$envsubst_cmd" \
      -v has_stdbuf="$has_stdbuf" \
      -v exists_cmd='while read -r p; do if [ -d "$p" ]; then echo "$p"; else echo; fi; done' \
      -e 'BEGIN { 
if (!has_stdbuf) # disable buffering
  PROCINFO[envsubst, "pty"] = 1
}' \
      -e '$1 ~ /@dirx|@file$/ {
  key = substr($1, 0, length($1)-5)

  path = ""
  for (i=2; i <= NF; i++) {
    path = path (i > 2 ? FS : "") $i
  }
  print path |& envsubst
  envsubst |& getline path

  # skip path when destination is empty.
  if (path ~ /^\s*$/) next

  # expand path when checking whether it exists
  if (path == "~" || path ~ /^~\//) {
    path = home substr(path, 2)
  }

  if (check_exists) {
    # pass through an exists cmd to assert whether a path
    # exists. exists_cmd should output one line for every
    # input line. The output should be empty if the path
    # does not exist.
    print path |& exists_cmd
    exists_cmd |& getline path

    if (path ~ /^\s*$/) next
  }

  if (home_relative && index(path, home) == 1) {
    path = "~" substr(path, length(home)+1)
  }

  print key sep path
}'
