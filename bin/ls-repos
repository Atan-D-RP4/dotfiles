#!/usr/bin/env bash
# List repositories on my system using the REPO_PATH environment variable.
#
# REPO_PATH points to directories which can contain one or more code repositories.
# REPO_PATH can contain globs such as ~/foo/*/* and all of the directories expanded
# by the glob will also be considered as potential repository containers.

repo_paths() {
  # Expand all the paths in REPO_PATH, including glob expansion.
  # This method also avoids duplicate paths in REPO_PATH by keeping
  # track of all the paths encountered so far.
  echo "${REPO_PATH//:/$'\n'}" |
    awk -e '{ if (!mem[$0]++) print($0) }' |
    while read -r path; do
      [ -z "$path" ] && continue
      for path in $path; do
        echo "$path"
      done
    done |
    perl -ne 'chomp(); if (-e $_) {print "$_\n"}'
    # filter out non-existant paths, from [[https://serverfault.com/a/609900][here]].
}

# NOTE: This script can use GNU parallel or xargs, but parallel is better
# because you can spawn a single find process with multiple paths. For xargs
# each path gets it's own find process, causing a general decrease in speed
# as the number of possible repo containers increase.
batch=(  )
if command -v parallel >/dev/null 2>&1; then
  batch+=( parallel -d '\n' -X -I% --line-buffer --quote )
else
  batch+=( xargs -d '\n' -I% )
fi

# The approach is to spawn a find process for each path that can potentially
# contain a repository, traverse over all the folders in those directories, upto
# depth 1, and assert a repository test on them.
repo_paths |
  "${batch[@]}" \
    find % -mindepth 1 -maxdepth 1 -type d -exec [ -e '{}/.git' -o -e '{}/GemFile' ] ';' -print
