#!/usr/bin/env bash
fzf_docker() {
  local USAGE HELP
  read -r -d '' USAGE <<EOF
Usage: fzf_docker [-h] [-c CMD]
EOF

  read -r -d '' HELP <<EOF
$USAGE

  Interactively select and run an interactive command
  within one of the container images built by docker.

Optional arguments:
  -h      Show this help message and exit
  -c CMD  Specify command to run within container
EOF

  cmd='bash -li'
  while getopts 'hc:' OPTION; do
    case "$OPTION" in
      h) echo "$HELP"
         return 0 ;;
      \?) echo "$USAGE"
          return 1 ;;
      c) cmd="$OPTARG" ;;
    esac
  done

  local sep=$'\t'
  fzf_args+=(
    -d "$sep" --ansi --with-nth '2..'
    --history "${XDG_STATE_HOME:-$HOME/.locale/state}"/fzf/history/docker
  )

  local green="$(printf '\e[32m')"
  local blue="$(printf '\e[34m')"
  local reset="$(printf '\e[0m')"
  # See [[https://docs.docker.com/engine/reference/commandline/images/#format-the-output][here]] for a list of available fields for this format string.
  local format="{{.ID}}$sep{{.Repository}}:$blue{{.Tag}}$reset [$green{{.Size}}$reset]"
  local id=$(docker images --format "$format" |
               sed 's/:[^:]\+<none>[^ ]\+//' |
               sort --key 2 -V --field-separator="$sep" |
               _fzf "${fzf_args[@]}" |
               cut -d"$sep" -f1)
  if [ -n "$id" ]; then
    # We mount our local docker socket into the container so we can run
    # docker builds using our outer daemon from within the image.
    docker \
      run --rm                                     \
      -v "$(pwd)":/workarea                        \
      -v /var/run/docker.sock:/var/run/docker.sock \
      --workdir /workarea                          \
      --interactive --tty                          \
      "$id"                                        \
      bash -c "$cmd"
  fi
}
