#!/usr/bin/env python3
"""
tmux status line segment for various miscellaneous segments that could be
incorporated into their own scripts but are kept together for simplicity
or experimentation.
"""

import argparse
import asyncio
import logging
import sys
from typing import Optional

from lib.shared import async_print_loop
from lib.status_misc import StatusMiscSegment


async def main(args: argparse.Namespace) -> None:
    """Run status-misc."""
    status_lock = asyncio.Lock()
    change_event = asyncio.Event()
    statuses = [None] * len(args.enabled)
    value_ptr = [""]

    tasks = []
    for i, segment in enumerate(args.enabled):
        logging.info("Activating segment %s", segment.name)

        # This needs to be wrapped because i is a cell-variable.
        def segment_callback(i: int):
            async def implementation(result: Optional[str]) -> None:
                async with status_lock:
                    if statuses[i] != result:
                        logging.debug(
                            "Updating value of segment=%s to value=%s",
                            args.enabled[i].name,
                            repr(result),
                        )
                        statuses[i] = result
                        line = args.sep.join(msg for msg in statuses if msg)
                        if line:
                            line = line + args.suffix
                        value_ptr[0] = line
                        change_event.set()

            return implementation

        tasks.append(asyncio.create_task(segment.run(segment_callback(i))))

    # This is safe because we technically have a lock on statuses until the
    # `print_loop` blocks and returns control to the async runtime.
    await asyncio.create_task(async_print_loop(value_ptr, change_event, args.unbuffer))

    for task in tasks:
        task.cancel()


if __name__ == "__main__":
    SEGMENTS = {x.name: x for x in StatusMiscSegment.__subclasses__()}

    def parse_args() -> argparse.Namespace:
        """Parse command line arguments."""
        parser = argparse.ArgumentParser()
        parser.add_argument(
            "--suffix", metavar="FORMAT", default="", help="Suffix output with FORMAT."
        )

        # NOTE: The orders of these determines order in output.
        parser.add_argument(
            "--enable",
            metavar="SEGMENT",
            action="append",
            default=[],
            dest="enabled",
            help="Enable a segment, one of: " + ", ".join(SEGMENTS.keys()),
        )

        parser.add_argument(
            "--log-level",
            metavar="LEVEL",
            type=lambda x: getattr(logging, x.upper()),
            default=logging.FATAL,
        )

        parser.add_argument(
            "--disable",
            metavar="SEGMENT",
            help="Disable a segment, one of those from --enable.",
        )

        parser.add_argument(
            "--sep",
            metavar="STRING",
            default=" ",
            help="Concatenate status indicators with STRING",
        )
        parser.add_argument(
            "-r",
            "--reset-style",
            default="#[default]",
            help="Specify style for resetting styles",
        )
        parser.add_argument(
            "-u",
            "--unbuffer",
            action="store_true",
            help="Immeadiately flush output after writing",
        )

        for segment in StatusMiscSegment.__subclasses__():
            segment.parser_args(parser)

        args = parser.parse_args()

        logging.basicConfig(level=args.log_level, stream=sys.stderr)

        for i, segment in enumerate(args.enabled):
            if segment not in SEGMENTS:
                parser.error(f"Unknown status-line segment enabled: {segment}")
            args.enabled[i] = SEGMENTS[segment](args)

        return args

    try:
        asyncio.run(main(parse_args()))
    except KeyboardInterrupt:
        sys.exit(1)
