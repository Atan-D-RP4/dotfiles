# -*- mode: sh -*- shell agnostic environment setup file.

#      _          _ _                    _                                      _
#  ___| |__   ___| | |    ___ _ ____   _(_)_ __ ___  _ __  _ __ ___   ___ _ __ | |_
# / __| '_ \ / _ \ | |   / _ \ '_ \ \ / / | '__/ _ \| '_ \| '_ ` _ \ / _ \ '_ \| __|
# \__ \ | | |  __/ | |  |  __/ | | \ V /| | | | (_) | | | | | | | | |  __/ | | | |_
# |___/_| |_|\___|_|_|___\___|_| |_|\_/ |_|_|  \___/|_| |_|_| |_| |_|\___|_| |_|\__|
#                   |_____|

# don't source this script if you've already sourced it.
[ -z "$SOURCED_SHENV" ] || return

[ -f "$HOME/.config/user-dirs.dirs" ] && . "$HOME/.config/user-dirs.dirs"

# platform dependent config
case "$OSTYPE" in
    cygwin*|msys*|win32*) platform="windows" ;;
    darwin*)              platform="macos"   ;;
    linux-gnu*)           platform="linux"   ;;
    *)
        platform=
        echo "bash_aliases(warning) : unknown os type: $OSTYPE" >&2
        ;;
esac

case "$TERM" in
    dumb)
        PS1="> " # dumb terminal used by emacs tramp
        ;;
    xterm*|rxvt*|eterm*|screen*|cygwin*|emacs*|st*)
        SMART_TERM=1 ;;
    *) SMART_TERM=0 ;;
esac

case "$(ps -p $$ | awk 'END { print($NF) }')" in
    *bash) shell="bash" ;;
    *zsh)  shell="zsh"  ;;
    *)     shell=       ;;
esac

# prioritize editors in order of nvim, vim, vi.
if   which nvim >/dev/null 2>&1; then export EDITOR=nvim
elif which vim  >/dev/null 2>&1; then export EDITOR=vim
else                                  export EDITOR=vi
fi

export VISUAL="$EDITOR"
export PAGER=less
export LESS="-R"
export DOTFILES_REPO_PATH=$HOME/.dotfiles
export TMUX_TMPDIR=$HOME/.tmux/tmp/
export EMACS_SERVER_FILE=$HOME/.emacs.d/var/server/server
export LANG=en_GB.UTF-8 LC_MESSAGES="C"

# XDG compatibility for various programs, see [[https://wiki.archlinux.org/index.php/XDG_Base_Directory][here]].
export INPUTRC="$XDG_CONFIG_HOME"/readline/inputrc
export BUNDLE_USER_CONFIG="$XDG_CONFIG_HOME"/bundle
export BUNDLE_USER_CACHE="$XDG_CACHE_HOME"/bundle
export BUNDLE_USER_PLUGIN="$XDG_DATA_HOME"/bundle
export IRBRC="$XDG_CONFIG_HOME"/irb/irbrc

# Custom Configuration Paths
export PROGRAM_DIR=$HOME/programming
export SCRIPTS_DIR="$PROGRAM_DIR"/scripts

export PYTHONIOENCODING="utf-8" # prevents error msg

HISTSIZE=1000 HISTFILESIZE=2000 HISTFILE=~/.history

# set terminal used by i3
export TERMINAL="st"

# set path based variables
lines_to_path() { #(PATH [...PATH])
    # converts a list of paths into a PATH like string sequence,
    # with support for comments and auto removal of empty lines.

    # NOTE trailing whitespace is automatically removed with
    #      inline comments.

    if [ $# -gt 0 -a ! -z "$1" ]; then
        # print existing path variables when given
        # in linux path format.

        case "${OSTYPE}" in
            *cygwin|*msys)
                printf "%s:" "$(cygpath --path "$*")"
                ;;
            *)
                printf "%s:" "$*"
                ;;
        esac
    fi
    local home=$(sed -e 's/\//\\\//g' <<< "$HOME")

    sed -e 's/ *#.*$//g' -e '/^ *$/d' -e 's ^~/ '"${HOME}"/' g' | tr '\n' ':' | sed -e 's/:$//'
    # strip out empty lines and comments, replace ~/ with users home directory & join paths with a :
}

export PATH=`lines_to_path $PATH <<EOF
~/programming/scripts/public
~/.local/bin/
$SCRIPTS_DIR
$PROGRAM_DIR/bin
$PROGRAM_DIR/.modules/node
$PROGRAM_DIR/.modules/ruby/bin
$PROGRAM_DIR/.modules/go/bin
~/.rvm/bin
EOF`

export CLASSPATH=`lines_to_path "$CLASSPATH" <<EOF
.
# WARN you need to specify both the directory with
#      wildcards to reference JARs and without them
#      for finding classes from that directory.
# WARN for some dumb reason... java & javac just
#      completely ignore this environment variable
#      when you pass the -cp argument.
$PROGRAM_DIR/.modules/java/
$PROGRAM_DIR/.modules/java/*
EOF`

export PYTHONPATH=`lines_to_path "$PYTHONPATH" <<EOF
$PROGRAM_DIR/.modules/python
EOF`

export GEM_HOME=$PROGRAM_DIR/.modules/ruby
export GEM_PATH=`lines_to_path "$GEM_PATH" <<EOF
$PROGRAM_DIR/.modules/ruby
EOF`

export GOPATH=`lines_to_path $GOPATH <<EOF
~/programming/.modules/go
EOF`

if [ "$platform" = "windows" ]; then
    for path_var in CLASSPATH PYTHONPATH GEM_HOME; do
        # for programs that don't care about the environment,
        # only about the OS, convert paths back to a windows
        # like path.

        export $path_var=$(cygpath --windows --path "$(echo "${!path_var}")")
    done
fi

unset -f lines_to_path # thank you, good bye

# uses darcula theme from fzf color schemes wiki
export FZF_DEFAULT_OPTS="
    --bind ctrl-j:down
    --bind ctrl-k:up
    --bind ctrl-u:page-up
    --bind ctrl-d:page-down
    --bind alt-h:backward-word
    --bind alt-l:forward-char
    --bind alt-g:jump-accept
    --bind alt-j:jump-accept
    --bind shift-left:backward-word
    --bind shift-right:forward-word
    --bind ctrl-space:toggle+down
    --color dark
    --color fg:-1,bg:-1,hl:#5fff87,fg+:-1,bg+:-1,hl+:#ffaf5f
    --color info:#af87ff,prompt:#5fff87,pointer:#ff87d7,marker:#ff87d7,spinner:#ff87d7
"

# source shortcuts
shortcuts_dir="$XDG_CONFIG_HOME/shortcuts"
[ -f "$shortcuts_dir/shortcuts" ] && . "$shortcuts_dir/shortcuts"
[ ! -z "$shell" -a -f "$shortcuts_dir/$shell" ] && . "$shortcuts_dir/$shell"
unset shortcuts_script

# source aliases
case "$-" in
    *i*)
        if which thefuck >/dev/null 2>&1; then
            # honestly I doubt I'll really be using 'the-fuck' but
            # lazy loading it is a near effortless task so why not

            # lazy load 'the fuck' using an alias which evaluates
            # it removes the alias and then runs it for the first
            # time

            alias='fx' # alias under which 'the-fuck' will be invoked... actually a function
            alias $alias='eval $(thefuck --alias '$alias') && unalias '$alias' && '$alias
            unset alias # remove a basically uselass environment variable from the shell
        fi

        build_aliases_script="$SCRIPTS_DIR/private/build_aliases.sh"
        if [ ! -x "$build_aliases_script" ]; then
            printf "bash_aliases(error) : failed to find build aliases script: %s\n" "$1" >&2
        else
            aliases_root="$XDG_CONFIG_HOME/aliases"

            # nicest way to check whether the files exist or not, and then build aliases
            eval "$(find $aliases_root/global    $aliases_root/global.private    \
                         $aliases_root/$platform $aliases_root/$platform.private \
                         -exec "$build_aliases_script" -i1 '{}' + 2>/dev/null)"

            unset aliases_root
        fi

        unset build_aliases_script shell

        alias sd='sudo '
        ;;
esac

SOURCED_SHENV=1
