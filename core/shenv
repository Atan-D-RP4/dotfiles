#!/usr/bin/env bash
# -*- +indent: 2 -*- Shell agnostic environment setup file.
#      _          _ _                    _                                      _
#  ___| |__   ___| | |    ___ _ ____   _(_)_ __ ___  _ __  _ __ ___   ___ _ __ | |_
# / __| '_ \ / _ \ | |   / _ \ '_ \ \ / / | '__/ _ \| '_ \| '_ ` _ \ / _ \ '_ \| __|
# \__ \ | | |  __/ | |  |  __/ | | \ V /| | | | (_) | | | | | | | | |  __/ | | | |_
# |___/_| |_|\___|_|_|   \___|_| |_|\_/ |_|_|  \___/|_| |_|_| |_| |_|\___|_| |_|\__|
#
#
# shellcheck disable=SC2034

smart_term=0
case "$TERM" in
  xterm*|rxvt*|eterm*|screen*|tmux*|cygwin*|emacs*|st*|alacritty)
    smart_term=1
    ;;
  dumb)
    PS1="> " # dumb terminal used by emacs tramp
    ;;
esac

[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"                    # Make less more friendly for non-text input files, see lesspipe(1)

# Generate lesskey configuration file when it's out of date.
[ -n "$LESSKEY" ] &&
  command -v lesskey >/dev/null 2>&1 &&
  [ -e "$LESSKEY.base" -a "$LESSKEY.base" -nt "$LESSKEY" ] &&
  lesskey "$LESSKEY.base"

# Apply custom color scheme for ls (for some reason this doesn't
# work in ~/.profile :?).
if [ -z "$LS_COLORS" -a \
     -x /usr/bin/dircolors -a \
     -r "$XDG_CONFIG_HOME/dircolors" ]; then
  eval "$(/usr/bin/dircolors -b "$XDG_CONFIG_HOME/dircolors")" ||
      eval "$(/usr/bin/dircolors -b)"
  # shellcheck disable=SC2153
  export LF_COLORS="$LS_COLORS:.git/=35:.github/=35"
fi

export SAVEHIST=10000000 HISTSIZE=10000000 HISTFILESIZE=10000000

FZF_SHELL_OPTS="--height 99% --reverse"                                         # FZF options for use in interactive shells and widgets.

# Might be assigned by [[file:~/.profile][profile]].
if [ -z "$shell" ]; then
  case "$(ps -p $$ | awk 'END { print($NF) }')" in
    *bash) shell="bash"   ;;
    *zsh)  shell="zshell" ;;
    *)     shell=         ;;
  esac
fi

# Source autoloads
[                   -f "$XDG_CONFIG_HOME/autoloads/global"       ] && . "$XDG_CONFIG_HOME/autoloads/global"
[ -n "$shell"    -a -f "$XDG_CONFIG_HOME/autoloads/shell/$shell" ] && . "$XDG_CONFIG_HOME/autoloads/shell/$shell"
[ -n "$platform" -a -f "$XDG_CONFIG_HOME/autoloads/$platform"    ] && . "$XDG_CONFIG_HOME/autoloads/$platform"

# Reclaim C-s and C-q
if [ "$smart_term" -eq 1 ]; then
  stty stop  undef 2>/dev/null
  stty start undef 2>/dev/null
fi

# source aliases
interactive=0
case "$-" in
  *i*)
    interactive=1

    if command -v thefuck >/dev/null 2>&1; then
      # Honestly I doubt I'll really be using 'the-fuck' but
      # lazy loading it is a near effortless task so why not

      # Lazy load 'the fuck' using an alias which evaluates
      # it removes the alias and then runs it for the first
      # time

      alias fx='eval "$(thefuck --alias fx)" && unalias fx && fx'
    fi

    load-aliases() { eval "$(ls-aliases | xargs -d '\n' -r build-aliases -1c -e e)"; }
    load-aliases
    ;;
esac

case "$TERM" in
  *-24bit)
    alias \
      ssh='TERM=screen-256color ssh' \
      journalctl='TERM=screen-256color journalctl' \
      systemctl='TERM=screen-256color systemctl' \
      bluetoothctl='TERM=screen-256color bluetoothctl'
    ;;
esac

[ -r "$XDG_CONFIG_HOME/shenv.local" ] &&
  . "$XDG_CONFIG_HOME/shenv.local"

unset shell

if [ "${interactive:-0}" -ne 0 \
    -a "${SH_BANNER:-0}" -gt 0 \
    -a -n "$COLUMNS" \
    -a -d "$XDG_CONFIG_HOME/banners" \
    -a -r "$XDG_CONFIG_HOME/banners" ] && \
     command -v "show-banners" >/dev/null 2>&1; then
  banner=$(find -L "$XDG_CONFIG_HOME/banners" -type f -or -type l |
             sort -R |
             while read -r b; do
               IFS=: read -r width _ < "$b"
               if [ "$width" -le "$COLUMNS" ]; then
                 echo "$b"
                 break
               fi
             done)
  [ -n "$banner" ] &&
    show-banners -c "$COLUMNS" "$banner"
  unset banner
fi
