#!/bin/bash

#  _               _         ____  ____  _
# | |__   __ _ ___| |__     |  _ \/ ___|/ |
# | '_ \ / _` / __| '_ \    | |_) \___ \| |
# | |_) | (_| \__ \ | | |   |  __/ ___) | |
# |_.__/ \__,_|___/_| |_|___|_|   |____/|_|
#                      |_____|

# bash script to setup and configure my bash prompt. The bash prompt is a direct
# fork of the bash prompt used by default in CMDer, with some mild enhancements.
#
# Default format is:
#
# username@hostname path (git-branch)
# λ
#
# Environment Variables:
#  PS1_INLINE:      when set to 1, bash prompt won't spread over multiple lines.
#  PS1_COLOR_CODED: when set to 1, bash prompt will change color depending on the
#                   exit code of the last command.
#

git_prompt_path="$SCRIPTS_DIR/.ps1/git-prompt.sh"

if ! hash __git_ps1 1>/dev/null 2>&1; then
    if [ -f "$git_prompt_path" ]; then
        . "$git_prompt_path" # source git prompt script to define __git_ps1
    else
        echo "bash_ps1(error) : git prompt script not found: $git_prompt_path" >&2
        __git_ps1() { echo ""; } # when not given, git PS1 just shows an empty string
    fi
fi

_pre_prompt() {
    local previous_exit_code="$?" user_color="\[\e[0;32m\]"

    if [ "${PS1_COLOR_CODED:-0}" = 1 ]; then
        local new_user_color="$($scripts_path/.ps1/error_colors.sh "$previous_exit_code")"
        [ $? -eq 0 ] && user_color="$new_user_color" # assign color based on last exit code
    fi

    local ps1_pre="$user_color\u@\h \[\e[33m\]\w\[\e[1;34m\]\$(__git_ps1)" ps1_post="\[\e[0m\]λ "
    if [ "${PS1_INLINE:-0}" = 1 ]; then ps1_pre="$ps1_pre "; else ps1_pre="$ps1_pre"$'\n'; fi
    PS1="$ps1_pre$ps1_post\[\e[0m\]"

    return "$previous_exit_code"
}

export PROMPT_COMMAND=_pre_prompt
